#!/usr/bin/env python2

# Copyright (c) 2012 Jeppe Ledet-Pedersen <jlp@satlab.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function

import sys
import time
import os.path
import argparse
import bluebox

subcommands = {}
def subcommand(help="", description=""):
	def _decorator(func):
		c = {"func": func, "help": help, "args": [], "description": description}
		subcommands[func.__name__] = c
		return func
	return _decorator

def argument(*args, **kwargs):
	def _decorator(func):
		_option = (args, kwargs)
		subcommands[func.__name__]["args"].append(_option)
		return func
	return _decorator
	
@subcommand("boot device into bootloader")
def bootloader(args, bb):
	bb.bootloader()

@subcommand("show RF silicon revision")
def version(args, bb):
	ver = bb.version()
	print(hex(ver))

@subcommand("show current RSSI reading in dBm")
def rssi(args, bb):
	rssi = bb.rssi()
	print("{0} dBm".format(rssi))

@subcommand("continuously show RSSI reading")
def signal(args, bb):
	minimum = -130
	maximum = -47
	width = 40

	while True:
		try:
			rssi = bb.rssi()
			if rssi < minimum:
				rssi = minimum
			if rssi > maximum:
				rssi = maximum

			progress = (rssi+abs(minimum))*width/(maximum+abs(minimum))

			bar = "[" + progress * "#" + (width-progress) * " " + "]"

			sys.stdout.write("\r{0} {1} dBm ".format(bar, rssi))
			sys.stdout.flush()
			time.sleep(0.5)
		except Exception as e:
			print(e)
			break

@subcommand("receive packets and print to screen")
def receive(args, bb):
	last = time.time()
	while True:
		data = bb.receive()
		if data is None:
			break
		print("Recv ({0}) {1:.2f}s '{2}'".format(len(data), time.time() - last, ''.join(["{0:02x}".format(x) for x in data])))
		last = time.time()

@argument('packet', help="packet hex string to transmit")
@subcommand("transmit packet data")
def transmit(args, bb):
	bytes = args.packet.decode("hex")
	bb.transmit(bytes)

@argument('mode', type=int, help="testmode type")
@subcommand("put device in test mode")
def testmode(args, bb):
	if args.mode == "carrier":
		bb.testmode(bb.TESTMODE_OFF)
		bb.tx_mode()
	elif args.mode == "high":
		bb.testmode(bb.TESTMODE_PATTERN_HIGH)
		bb.tx_mode()
	elif args.mode == "low":
		bb.testmode(bb.TESTMODE_PATTERN_LOW)
		bb.tx_mode()
	elif args.mode == "pn9":
		bb.testmode(bb.TESTMODE_PATTERN_PN9)
		bb.tx_mode()
	elif args.mode == "1010":
		bb.testmode(bb.TESTMODE_PATTERN_1010)
		bb.tx_mode()
	elif args.mode == "syncword":
		bb.testmode(bb.TESTMODE_PATTERN_SWD)
		bb.tx_mode()
	elif args.mode == "off":
		bb.testmode(bb.TESTMODE_OFF)
		bb.rx_mode()

@subcommand("set device in transmit mode")
def txmode(args, bb):
	bb.tx_mode()

@subcommand("set device in receive mode")
def rxmode(args, bb):
	bb.rx_mode()

@argument('frequency', type=int, help="requested frequency", nargs="?", default=None)
@subcommand("get or set device frequency")
def frequency(args, bb):
	if args.frequency is not None:
		bb.set_frequency(args.frequency)
	else:
		print(bb.get_frequency())

@argument('bitrate', type=int, help="requested bitrate", nargs="?", default=None)
@subcommand("get or set device bitrate")
def bitrate(args, bb):
	if args.bitrate is not None:
		bb.set_bitrate(args.bitrate)
	else:
		print(bb.get_bitrate())

@argument('modindex', type=int, help="requested modulation index", nargs="?", default=None)
@subcommand("get or set device modulation index")
def modindex(args, bb):
	if args.modindex is not None:
		bb.set_modindex(args.modindex)
	else:
		print(bb.get_modindex())

@argument('command', help="detailed help command", nargs="?", default=None)
@subcommand("show detailed help for subcommand")
def help(args, parser):
	if args.command is not None:
		subcommands[args.command]["parser"].print_help()
	else:
		parser.print_help()

class SubcommandHelpFormatter(argparse.RawDescriptionHelpFormatter):
	def _format_action(self, action):
		# determine the required width and the entry label
		help_position = min(self._action_max_length + 2,
							self._max_help_position)
		help_width = self._width - help_position
		action_width = help_position - self._current_indent - 2
		action_header = self._format_action_invocation(action)

		# ho nelp; start on same line and add a final newline
		if not action.help:
			tup = self._current_indent, '', action_header
			action_header = '%*s%s\n' % tup

		# short action name; start on the same line and pad two spaces
		elif len(action_header) <= action_width:
			tup = self._current_indent, '', action_width, action_header
			action_header = '%*s%-*s  ' % tup
			indent_first = 0

		# long action name; start on the next line
		else:
			tup = self._current_indent, '', action_header
			action_header = '%*s%s\n' % tup
			indent_first = help_position

		# collect the pieces of the action help
		parts = [action_header] if not action.nargs == argparse.PARSER else []

		# if there was help for the action, add lines of help text
		if action.help:
			help_text = self._expand_help(action)
			help_lines = self._split_lines(help_text, help_width)
			parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))
			for line in help_lines[1:]:
				parts.append('%*s%s\n' % (help_position, '', line))

		# or add a newline if the description doesn't end with one
		elif not action_header.endswith('\n'):
			parts.append('\n')

		# if there are any sub-actions, add their help as well
		for subaction in self._iter_indented_subactions(action):
			parts.append(self._format_action(subaction))

		# return a single string
		return self._join_parts(parts)

desc = """
Main BlueBox satellite ground station control program. %(prog)s is used for
controlling frequency, bitrate, etc. of the device and to transmit and
receive data.

"""

epilog="See '%(prog)s help <command>' for more information on a specific command."

def main():
	parser = argparse.ArgumentParser(description=desc, epilog=epilog, formatter_class=SubcommandHelpFormatter)
	parser.add_argument("-v", "--verbose", action="store_true", help="enable verbose output")
	subparsers = parser.add_subparsers(title="The available subcommands are", metavar="<command>")

	for sub in sorted(subcommands):
		subparser = subparsers.add_parser(sub, help=subcommands[sub]["help"], description=subcommands[sub]["description"])
		subcommands[sub]["parser"] = subparser
		for args, kwargs in subcommands[sub]["args"]:
			arg = args[0] if kwargs.get("nargs", "") == "?" else "<" + args[0] + ">"
			subparser.add_argument(*args, metavar=arg, **kwargs)
		subparser.set_defaults(func=subcommands[sub]["func"])

	if len(sys.argv) < 2:
		parser.print_help()
		sys.exit(1)

	args = parser.parse_args()
	if args.func == help:
		args.func(args, parser)
		sys.exit(0)

	try:
		bb = bluebox.Bluebox()
	except KeyboardInterrupt:
		sys.exit(0)
	except Exception as e:
		print("Failed to connect to BlueBox: {0}".format(e))
		sys.exit(0)

	if args.verbose:
		print("Found {0} {1} with serial {2} on bus {3}:{4}".format(
		      bb.manufacturer, bb.product, bb.serial, bb.bus, bb.address))

	try:
		args.func(args, bb)
	except Exception as e:
		print("Error: {0}".format(str(e)))
	sys.exit(0)

if __name__ == "__main__":
	main()
