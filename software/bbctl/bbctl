#!/usr/bin/env python2

# Copyright (c) 2012 Jeppe Ledet-Pedersen <jlp@satlab.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function

import sys
import time
import os.path
import argparse

import bluebox
import fec

subcommands = {}
def subcommand(*args, **kwargs):
	def _decorator(func):
		nargs = list(args)
		help = nargs[0]
		nargs[0] = func.__name__
		kwargs["help"] = help
		_option = (nargs, kwargs)
		if not subcommands.has_key(func.__name__):
			subcommands[func.__name__] = {}
		subcommands[func.__name__]["sub"] = _option
		subcommands[func.__name__]["func"] = func
		if not subcommands[func.__name__].has_key("args"):
			subcommands[func.__name__]["args"] = []
		return func
	return _decorator

def argument(*args, **kwargs):
	def _decorator(func):
		_option = (args, kwargs)
		if not subcommands.has_key(func.__name__):
			subcommands[func.__name__] = {}
		if not subcommands[func.__name__].has_key("args"):
			subcommands[func.__name__]["args"] = []
		subcommands[func.__name__]["args"].insert(0, _option)
		return func
	return _decorator

colors = {"gray": 30, "red": 31, "green": 32, "yellow": 33, "blue": 34,
	  "magenta": 35, "cyan": 36, "white": 37, "crimson": 38}

def color_print(color, text):
	print("\033[{0}m{1}\033[0m".format(color, text))

def parse_frequency(s):
	prefixes = {'K': 1e3, 'M': 1e6, 'G': 1e9}
	mult = 1
	if s.lower().endswith("hz"):
		s = s[:-2]
	for prefix in prefixes.keys():
		if s.upper().endswith(prefix):
			mult = prefixes[prefix]
			s = s[:-1]
			break
	try:
		hz = int(float(s)*mult)
	except:
		raise argparse.ArgumentTypeError("{} is not a valid frequency".format(s))

	return hz

def parse_int(s):
	try:
		integer = int(s, 0)
	except:
		raise argparse.ArgumentTypeError("{} is not a valid integer".format(s))

	return integer
	
@subcommand("boot device into DFU mode")
def dfu(args, bb):
	bb.dfu()

@subcommand("show RF silicon revision")
def version(args, bb):
	ver = bb.version()
	print(hex(ver))

@subcommand("show current RSSI reading in dBm")
def rssi(args, bb):
	rssi = bb.rssi()
	print("{0} dBm".format(rssi))

@subcommand("continuously show RSSI reading")
def signal(args, bb):
	minimum = -130
	maximum = -47
	width = 40

	while True:
		try:
			rssi = bb.rssi()
			if rssi < minimum:
				rssi = minimum
			if rssi > maximum:
				rssi = maximum

			progress = (rssi+abs(minimum))*width/(maximum+abs(minimum))

			bar = "[" + progress * "#" + (width-progress) * " " + "]"

			sys.stdout.write("\r{0} {1} dBm ".format(bar, rssi))
			sys.stdout.flush()
			time.sleep(0.1)
		except KeyboardInterrupt:
			print()
			sys.exit(0)
		except Exception as e:
			print(e)
			break

@subcommand("receive packets and print to screen")
@argument('-d', '--decode', dest="decode", help="decode packets", action='store_true', default=False)
@argument('-k', '--key', dest="key", help="HMAC key", default=None)
def receive(args, bb):
	count = 0
	ph = fec.PacketHandler(args.key)
	while True:
		bit_corr = 0
		byte_corr = 0
		data, rssi, freq = bb.receive()
		if data is None:
			continue

		if args.decode:
			try:
				data, bit_corr, byte_corr = ph.deframe(data)
			except:
				byte_corr = -1
		
		color = colors["red"] if byte_corr == -1 else colors["yellow"] if bit_corr or byte_corr else colors["green"]
		color_print(color, "{0:03} {1:.2f} RX ({2:03d}/{3:03d}) {4:4} dBm {5:+d} Hz ({6:03}) '{7}'".format(count, time.time(), bit_corr, byte_corr, rssi, freq, len(data), data.encode("hex")))
		count += 1

@subcommand("transmit packet data")
@argument('packet', help="packet hex string to transmit")
@argument('-r', '--wait-reply', dest="wait_reply", help="wait for reply", action='store_true', default=False)
@argument('-e', '--encode', dest="encode", help="encode packets", action='store_true', default=False)
@argument('-d', '--decode', dest="decode", help="decode packets", action='store_true', default=False)
@argument('-k', '--key', dest="key", help="HMAC key", default=None)
@argument('-c', '--continuous', dest="continuous", help="Continuously send data", action="store_true")
@argument('-s', '--switch', dest="switch", help="Switching time in ms", type=int, default=0)
def transmit(args, bb):
	continuous = True
	tx_count = 0
	rx_count = 0

	if args.encode or args.decode:
		ph = fec.PacketHandler(args.key)

	while continuous:
		bytes = args.packet.decode("hex")
		color_print(colors["blue"], "{0:03} {1:.2f} TX ({2}) '{3}'".format(tx_count, time.time(), len(bytes), bytes.encode("hex")))
		if args.encode:
			bytes = ph.frame(bytes)

		if args.verbose:
			print("Transmit data:")
			print(ph.hexdump(bytes))

		bb.transmit(bytes)
		tx_count += 1
		if args.wait_reply:
			data, rssi, freq = bb.receive()
			if data is None:
				color_print(colors["yellow"], "Timeout while waiting for reply reply")
			else:
				bit_corr = 0
				byte_corr = 0

				if args.verbose:
					print("Receive data:")
					print(ph.hexdump(data))

				if args.decode:
					try:
						data, bit_corr, byte_corr = ph.deframe(data)
					except:
						byte_corr = -1
				
				color = colors["red"] if byte_corr == -1 else colors["yellow"] if bit_corr or byte_corr else colors["green"]

				color_print(color, "{0:03} {1:.2f} RX ({2:03d}/{3:03d}) {4:4} dBm {5:+d} Hz ({6:03}) '{7}'".format(rx_count, time.time(), bit_corr, byte_corr, rssi, freq, len(data), data.encode("hex")))
				rx_count += 1

		continuous = args.continuous
		time.sleep(args.switch/1000.0)

testmode_desc = """
This command puts the BlueBox in testmode and transmits a test signal.

The available test signals are:
  carrier    continuously transmit carrier frequency
  0101       transmit sequency of alternating 0's and 1's
  high       transmit 1 frequency
  low        transmit 0 frequency
  pn9        transmit PN9 pattern
  syncword   continuously transmit programmed syncword
  off        disable test pattern
"""

@subcommand("put device in test mode", description=testmode_desc)
@argument('mode', help="test signal", choices=("carrier", "high", "low", "pn9", "1010", "syncword", "off"))
@argument('-l', '--limit', type=int, metavar="seconds", help="stop after limit seconds")
def testmode(args, bb):
	if args.mode == "carrier":
		bb.testmode(bb.TESTMODE_OFF)
		bb.tx_mode()
	elif args.mode == "high":
		bb.testmode(bb.TESTMODE_PATTERN_HIGH)
		bb.tx_mode()
	elif args.mode == "low":
		bb.testmode(bb.TESTMODE_PATTERN_LOW)
		bb.tx_mode()
	elif args.mode == "pn9":
		bb.testmode(bb.TESTMODE_PATTERN_PN9)
		bb.tx_mode()
	elif args.mode == "1010":
		bb.testmode(bb.TESTMODE_PATTERN_1010)
		bb.tx_mode()
	elif args.mode == "syncword":
		bb.testmode(bb.TESTMODE_PATTERN_SWD)
		bb.tx_mode()
	elif args.mode == "off":
		bb.testmode(bb.TESTMODE_OFF)
		bb.rx_mode()

	if args.mode != "off" and args.limit is not None:
		time.sleep(args.limit)
		bb.testmode(bb.TESTMODE_OFF)
		bb.rx_mode()

@subcommand("set device in transmit mode")
def txmode(args, bb):
	bb.tx_mode()

@subcommand("set device in receive mode")
def rxmode(args, bb):
	bb.rx_mode()

@subcommand("get or set device frequency")
@argument('frequency', help="requested frequency", type=parse_frequency, nargs="?", default=None)
def frequency(args, bb):
	if args.frequency is not None:
		bb.set_frequency(args.frequency)
	else:
		print(bb.get_frequency())

@subcommand("get or set device bitrate")
@argument('bitrate', type=int, help="requested bitrate", nargs="?", default=None)
def bitrate(args, bb):
	if args.bitrate is not None:
		bb.set_bitrate(args.bitrate)
	else:
		print(bb.get_bitrate())

@subcommand("get or set device modulation index")
@argument('modindex', type=int, help="requested modulation index", nargs="?", default=None)
def modindex(args, bb):
	if args.modindex is not None:
		bb.set_modindex(args.modindex)
	else:
		print(bb.get_modindex())

@subcommand("get or set device training sequence")
@argument('length', type=int, help="training sequence length in bytes", nargs="?", default=None)
def training(args, bb):
	if args.length is not None:
		bb.set_training(args.length)
	else:
		print(bb.get_training())

@subcommand("get or set device power level")
@argument('power', type=int, help="power level (ADF702x PA setting, not in dBm!)", nargs="?", default=None)
def power(args, bb):
	if args.power is not None:
		bb.set_power(args.power)
	else:
		print(bb.get_power())

@subcommand("basic spectrum analysis")
@argument("-c", metavar="center", dest="center", type=parse_frequency, help="center frequency in Hz", default=str(437.45e6))
@argument("-s", metavar="span", dest="span", type=parse_frequency, help="frequency span in Hz", default=str(5e3))
@argument("-b", metavar="bins", dest="bins", type=int, help="number of bins to divide span in", default=10)
def spectrum(args, bb):
	center = args.center
	span = args.span
	bins = args.bins

	if center - span < 0:
		raise Exception("Invalid span")

	print("showing spectrum from {0} Hz to {1} Hz in {2} bins".format(
					center-span//2, center+span//2, bins))

	orig_freq = bb.get_frequency()
	for freq in range(center - span//2, center + span//2+1, span//bins):
		bb.set_frequency(freq)
		rssi = bb.rssi()
		print("{0}: {1} dBm".format(freq, rssi))
	bb.set_frequency(orig_freq)

@subcommand("show current configuration")
def config(args, bb):
	frequency    = bb.get_frequency()
	modindex     = bb.get_modindex()
	training     = bb.get_training()
	bitrate      = bb.get_bitrate()
	received     = bb.get_received()
	transmitted  = bb_get_transmitted()

	print("Frequency:        {0:.3f} MHz".format(frequency/1.0e6))
	print("Modulation Index: {0}".format(modindex))
	print("Bitrate:          {0} bps".format(bitrate))
	print("Training bytes:   {0} bytes".format(training))

@subcommand("set ADF7021 register")
@argument("register", type=parse_int, help="register number to write")
@argument("value", type=parse_int, help="new register value")
def register(args, bb):
	bb.reg_write(args.register, (args.value << 8))

@subcommand("show detailed help for subcommand")
@argument('command', help="detailed help command", nargs="?", default=None)
def help(args, parser):
	if args.command is not None:
		subcommands[args.command]["parser"].print_help()
	else:
		parser.print_help()

class SubcommandHelpFormatter(argparse.RawDescriptionHelpFormatter):
	def _format_action(self, action):
		parts = super(argparse.RawDescriptionHelpFormatter, self)._format_action(action)
		if action.nargs == argparse.PARSER:
			parts = "\n".join(parts.split("\n")[1:])
		return parts

desc = """
Main BlueBox satellite ground station control program. %(prog)s is used for
controlling frequency, bitrate, etc. of the device and to transmit and
receive data.

The BlueBox firmware and bbctl is free software licensed under the MIT license.
For more information see http://www.satlab.org or http://github.com/satlab

"""

epilog="See '%(prog)s help <command>' for more information on a specific command."

def main():
	parser = argparse.ArgumentParser(description=desc, epilog=epilog, formatter_class=SubcommandHelpFormatter)
	parser.add_argument("-d", metavar="<device>", default=None, help="select specific BlueBox device")
	parser.add_argument("-t", metavar="<timeout>", dest="timeout", type=int, default=10000, help="set transfer timeout in ms")
	parser.add_argument("-v", "--verbose", action="store_true", help="enable verbose output")
	parser.add_argument("-w", "--wait", action="store_true", help="wait for device if not connected")
	subparsers = parser.add_subparsers(title="The available subcommands are", metavar="<command>")

	for sub in sorted(subcommands):
		args, kwargs = subcommands[sub]["sub"]
		subparser = subparsers.add_parser(*args, formatter_class=SubcommandHelpFormatter, **kwargs)
		subcommands[sub]["parser"] = subparser
		for args, kwargs in subcommands[sub]["args"]:
			arg = args[0] if kwargs.get("nargs", "") == "?" else "<" + args[0] + ">"
			if not args[0].startswith("-"):
				kwargs["metavar"] = kwargs.get("metavar", arg)
			subparser.add_argument(*args, **kwargs)
		subparser.set_defaults(func=subcommands[sub]["func"])

	if len(sys.argv) < 2:
		parser.print_help()
		sys.exit(1)

	if not sys.argv[1].startswith("-") and not sys.argv[1] in subcommands:
		print("{0}: '{1}' is not a {0} command. See '{0} --help'.".format(parser.prog, sys.argv[1]))
		sys.exit(1)

	args = parser.parse_args()
	if args.func == help:
		args.func(args, parser)
		sys.exit(0)

	try:
		bb = bluebox.Bluebox(wait=args.wait, timeout=args.timeout)
	except KeyboardInterrupt:
		print()
		sys.exit(0)
	except Exception as e:
		print("Failed to connect to BlueBox: {0}".format(e))
		sys.exit(0)

	if args.verbose:
		print("Found {0} {1} with serial {2} on bus {3}:{4}".format(
		      bb.manufacturer, bb.product, bb.serial, bb.bus, bb.address))

	try:
		args.func(args, bb)
	except Exception as e:
		print("Error: {0}".format(str(e)))
	except KeyboardInterrupt:
		print()
	sys.exit(0)

if __name__ == "__main__":
	main()
